<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - software-development</title>
    <link href="https://bspace.us/tags/software-development/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://bspace.us"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-09-17T00:00:00+00:00</updated>
    <id>https://bspace.us/tags/software-development/atom.xml</id>
    <entry xml:lang="en">
        <title>approaches to testing</title>
        <published>2021-09-17T00:00:00+00:00</published>
        <updated>2021-09-17T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://bspace.us/posts/art-of-testing/" type="text/html"/>
        <id>https://bspace.us/posts/art-of-testing/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;The evolution of testing -- what&#x27;s lost and gained?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;I have a project in which I&#x27;m parsing data.&lt;&#x2F;p&gt;
&lt;p&gt;One useful principle of testing is to have a discrete piece of functionality tested. And the most direct way to do that for parsing is to pass in source-data, and specify a clear assertion. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;simple-and-direct&quot;&gt;simple and direct&lt;&#x2F;h2&gt;
&lt;p&gt;I began that way: &lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L156&quot;&gt;Here&#x27;s&lt;&#x2F;a&gt; the beginning of Parser testing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L241-L246&quot;&gt;Here&#x27;s&lt;&#x2F;a&gt; the first iteration of parsing a patron note -- although the test was originally called, simply &lt;code&gt;test_parse_patron_note()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;That happened to be for a physical item; shortly thereafter I needed to parse the note for a digital item. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L248-L253&quot;&gt;Here&lt;&#x2F;a&gt; is the iteration that tested for that. &lt;&#x2F;p&gt;
&lt;p&gt;Implementing that second test, I renamed the first example to show that the test was for a physical item, and named the second test to show that it was testing a digital item. I could have passed just the specific item-xml or item-xml-object to each test. In some ways that would have been simpler and &amp;quot;purer&amp;quot;. But the real data for this project comes in a file containing multiple kinds of items, and I was going to be using the items for different kinds of tests (not just notes), so I figured I&#x27;d have one main test-file that would contain a variety of items to use for the tests. (Though this does add a slight dependency to the test -- file loading -- and dependences are frowned upon.)&lt;&#x2F;p&gt;
&lt;p&gt;In the two examples shown so far, I chose, from the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;test_dirs&#x2F;static_source&#x2F;BUL_ANNEX-sample.xml&quot;&gt;source-data&lt;&#x2F;a&gt; being tested, the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L244&quot;&gt;first list item&lt;&#x2F;a&gt; for the physical-note test, and the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L251&quot;&gt;sixth list item&lt;&#x2F;a&gt; for the digital-note test.&lt;&#x2F;p&gt;
&lt;p&gt;This is all reasonably forthright. The nice thing about this is that, coming back to this code in future weeks or months, and running the tests, I&#x27;d see from the terminal output, when running the test-suite, the explicit &lt;code&gt;test_parse_patron_note_physical()&lt;&#x2F;code&gt; and &lt;code&gt;test_parse_patron_note_digital()&lt;&#x2F;code&gt; tests. That&#x27;s really useful when revisiting code.&lt;&#x2F;p&gt;
&lt;p&gt;But the more edge-cases that arise, the benefits of this explicitness quickly, for me, feel outweighed by the duplication. I could have half-a-dozen explicit tests for parsing just the notes field for physical items, another half-dozen for digital items, and have lots of very specific tests for all the other parsing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;scalable&quot;&gt;scalable&lt;&#x2F;h2&gt;
&lt;p&gt;In this and other projects, in this situation, I&#x27;ve moved to a different pattern: a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Brown-University-Library&#x2F;parse_alma_annex_requests_code&#x2F;blob&#x2F;8109bdbf6b9ff3dd609d8d2c5c7775d72ad3de10&#x2F;tests.py#L221-L239&quot;&gt;single test&lt;&#x2F;a&gt; for parsing the target field (in this case the note). This single test first loads up an array of items, an array of expectations, and then iterates through the array, so the single test in this case is actually testing eight variations.&lt;&#x2F;p&gt;
&lt;p&gt;This has some real advantages -- it&#x27;s very scalable, since adding a new source-data item simply involves adding an expectation to this note, and the other parsed fields. I might be adding the new item because I&#x27;m aware of an edge-case for parsing, say, the item-barcode, and by having to also list the note expectation, I might end up catching some error I hadn&#x27;t been aware of.&lt;&#x2F;p&gt;
&lt;p&gt;BUT... there is loss with the gain. I need to view the comments (or the source-data) to see&#x2F;remember that I&#x27;m parsing physical vs digital items. (Might there be another digital item that I forgot to indicate via a comment?) And I&#x27;m not going to see those comments in the test-output. &lt;&#x2F;p&gt;
&lt;p&gt;I just remembered long ago implementing something like this with an additional field in the array. Instead of just handing two-elements in each loop iteration (the source-item-data, and the expectation) -- I also had a comment that was printed, too. That would restore some of the useful specificity of output -- and on a failure, allow me to target, more quickly, the location of the error.&lt;&#x2F;p&gt;
&lt;p&gt;This example of gain&#x2F;loss refactoring is a miniscule one -- but it reveals aspects of the decision-making in programming that I love.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>recursion</title>
        <published>2008-10-26T00:00:00+00:00</published>
        <updated>2008-10-26T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://bspace.us/posts/recursion/" type="text/html"/>
        <id>https://bspace.us/posts/recursion/</id>
        
        <content type="html">&lt;p&gt;After writing the code below recently, I searched out a few cohorts at work to share the joy, but it was late and no one was around...&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;  def makeHierarchicalFolderList( folder_object_list, return_list=[], indent=&amp;#39;&amp;#39; ):    
&lt;&#x2F;span&gt;&lt;span&gt;       &amp;#39;&amp;#39;&amp;#39;    
&lt;&#x2F;span&gt;&lt;span&gt;       - Called by: views.uploader3()    
&lt;&#x2F;span&gt;&lt;span&gt;       - Purpose: to create a list of community-folders (for upload form) with indents indicating hierarchical relationship. Will likely be replaced by better user-interface.    
&lt;&#x2F;span&gt;&lt;span&gt;       &amp;#39;&amp;#39;&amp;#39;    
&lt;&#x2F;span&gt;&lt;span&gt;                               
&lt;&#x2F;span&gt;&lt;span&gt;       for folder in folder_object_list:    
&lt;&#x2F;span&gt;&lt;span&gt;            folder.name = &amp;#39;%s%s&amp;#39; % ( indent, folder.name )    
&lt;&#x2F;span&gt;&lt;span&gt;            return_list.append( folder )    
&lt;&#x2F;span&gt;&lt;span&gt;                
&lt;&#x2F;span&gt;&lt;span&gt;            # check for children    
&lt;&#x2F;span&gt;&lt;span&gt;            children_count = folder.communityfolder_set.all().count()    
&lt;&#x2F;span&gt;&lt;span&gt;                
&lt;&#x2F;span&gt;&lt;span&gt;            # handle check-results    
&lt;&#x2F;span&gt;&lt;span&gt;            if children_count == 0:    
&lt;&#x2F;span&gt;&lt;span&gt;                 pass    
&lt;&#x2F;span&gt;&lt;span&gt;            else:    
&lt;&#x2F;span&gt;&lt;span&gt;                 children_object_list = folder.communityfolder_set.all()    
&lt;&#x2F;span&gt;&lt;span&gt;                 indent = indent + &amp;#39;-&amp;#39;    
&lt;&#x2F;span&gt;&lt;span&gt;                 makeHierarchicalFolderList( children_object_list, return_list, indent=indent )    
&lt;&#x2F;span&gt;&lt;span&gt;                 indent = indent[1:] # since we&amp;#39;re at the end of a processing chain, remove the indent    
&lt;&#x2F;span&gt;&lt;span&gt;                     
&lt;&#x2F;span&gt;&lt;span&gt;       return return_list    
&lt;&#x2F;span&gt;&lt;span&gt;                
&lt;&#x2F;span&gt;&lt;span&gt;       # end def makeHierarchicalCommunityFolderList()    
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What enthused me so was the line a few up from the bottom, where I call the very function in which this line resides. This is called recursion. There&#x27;s a wonderful slightly mysterious inverted mobius-strip-like quality to recursion, except that if done right, processing doesn&#x27;t continue on forever.&lt;&#x2F;p&gt;
&lt;p&gt;The code above neatly meets the needs of a project I&#x27;m working on: to prepare a hierarchical listing of folders. Not shown is an initial step in which a query is made for a user-specific list of &#x27;top-level&#x27; folders -- that is, folders which do not have a parent folder. For each folder in this list, the folder is first appended to a sort of global list-of-folders-to-return. Then a check is made to see if the folder has any children. If so, those child-folders are selected, and passed to the function itself. So for each top-level folder, a processing-chain begins that might be very, very long, or might be very short. But each processing-chain does terminate, shifting to examine the next sibling folder, and, when there are no more sibling-folders in the lowest-level generation, shifting back upward a generation to examine and process the next sibling-folder.&lt;&#x2F;p&gt;
&lt;p&gt;I use recursion infrequently enough that it sort of gets buried in my toolbox. I forget about it and from habit reach for other tools first that often do the looping job well-enough. Utilizing looping-logic is a fundamental part of programming. Where a built-in looping structure doesn&#x27;t directly solve looping needs, I most often use a Controller-pattern solution to a looping challenge. That is, I&#x27;ll have a controller block of code prepare a list of items that need to be looped through, and perhaps set some variables to hold the results of processing, and then call a separate function that handles the actual looping. Sometimes for more complex situations the called looping code can itself call another separate block of looping code. So it is possible to handle some situations, for which recursion might be ideal, with other techniques. But not all situations -- when my usual looping implementation begins feeling overly complex, that&#x27;s often a sign to root around and dust off the recursion tool.&lt;&#x2F;p&gt;
&lt;p&gt;Despite some left-over 1960&#x27;s geek-stereotypes about programming being a boring left-brain process, there can be elegance and deep beauty in programming. There are numerous ways to approach and solve a challenge, any of which may work &#x27;well-enough&#x27;. Good programmers strive for solutions that are simplest and clearest, and when the right technique lends itself to beautifully simple code, one feels like an artist.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
